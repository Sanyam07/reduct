import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output

import plotly.graph_objs as go

import pandas as pd
from sklearn.decomposition import PCA

import argparse

from ingest_data import parse_input

# Parse command-line
parser = argparse.ArgumentParser(description='App for visualising high-dimensional data')
parser.add_argument('infile', help='CSV file of data to visualise')
parser.add_argument('--separator', default=',', help='separator character in tabular input')
parser.add_argument('--num-pcs', type=int, default='10', help='number of principal components to present')
# max_PCs
args = parser.parse_args()

# read and parse data
data, sample_info, field_info = parse_input(args.infile, separator=args.separator)
fields = list(data.columns)
assert list(field_info.index) == fields

# do PCA
num_pcs = min(args.num_pcs, data.shape[1])
pca = PCA(num_pcs)
transformed = pd.DataFrame(pca.fit_transform(data.as_matrix()), index=data.index)
pca_names = ["PCA{}".format(n) for n in range(1,num_pcs+1)]
transformed.columns = pca_names
print("PCA results shape {}".format(transformed.shape))

pca_dropdown_values = [{'label':"{0} ({1:.3} of variance)".format(n,v), 'value':n}
                       for (n,v) in zip(pca_names,pca.explained_variance_ratio_)]


app = dash.Dash()

app.layout = html.Div(children=[
    #html.H1(children='Data embedding'),

    html.Label('X-axis'),
    dcc.Dropdown(
        id='x_dropdown',
        options = pca_dropdown_values,
        value='PCA1'
    ),

    html.Label('Y-axis'),
    dcc.Dropdown(
        id='y_dropdown',
        options = pca_dropdown_values,
        value='PCA2'
    ),

    html.Label('Colour points by'),
    dcc.Dropdown(
        id='colour_dropdown',
        options = [{'label':val,'value':val} for val in ['None']+list(sample_info.columns)],
        value='None'
    ),

    dcc.Graph(
        id='pca-plot'  # No figure - will be generated by callback
    )
])

@app.callback(
    Output('pca-plot','figure'),
    [Input('x_dropdown','value'), Input('y_dropdown','value'), Input('colour_dropdown','value')]
)
def update_figure(x_field, y_field, colour_field):
    if colour_field == 'None':
        traces = [go.Scatter(x=transformed[x_field], y=transformed[y_field], mode='markers',
                   marker=dict(size=10))]
    else:
        # Make separate traces to get colours and a legend.
        # Is this the best way?
        traces = []
        for value in sample_info[colour_field].unique():
            rows = sample_info[colour_field] == value
            traces.append(go.Scatter(x=transformed.loc[rows,x_field], y=transformed.loc[rows,y_field],
                          mode='markers', marker=dict(size=10), name=value))
    figure = {
        'data': traces,
        'layout': {
            'title': 'PCA',
            'xaxis': {'title': x_field},
            'yaxis': {'title': y_field},
        }
    }
    return figure

if __name__ == '__main__':
    app.run_server(debug=True)
